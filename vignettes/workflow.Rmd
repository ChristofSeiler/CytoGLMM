---
title: "CytoGLMM Workflow"
author: "Christof Seiler"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In this vignette we go through an entire CytoGLMM workflow with real data on NK cells. The data is part of a bigger studying the interaction between NK cells and monocytes when monocytes are exposed to two influenza A strains. In this workflow, we focus on the comparison between H1N1 or H3N2 strain after 24 hours of infection. Each cell is classified either as being exposed to either of the two simulation conditions. We examine the protein expression of 37 markers measured on NK cells (a CyTOF panel designed for NK cells) in the two conditions.

## Load Packages

To read FCS files we use the `flowCore` package.

```{r load_packages}
library(stringr)
library(flowCore)
```

## Read Data

To use the `CytoGLMM` package it is most convenient to convert the FCS files into a `data.frame` with marker expression as colums and cells as rows. Additionally, we append a column with donor identification numbers which will allows to account for donor specific variability.

```{r read_sample_table}
sample_table = read.csv("sample_table.csv")
sample_table$file_name = as.character(sample_table$file_name)
sample_table$donor = as.factor(sample_table$donor)
```

Read FCS files into a list and keep only markers that end with `Di`.

```{r read_fcs}
sample_list = lapply(sample_table$file_name,function(file_name_fcs) {
  fcsB = read.FCS(file_name_fcs,transformation = FALSE)
  marker_names = colnames(fcsB)[str_detect(colnames(fcsB),"[0-9]{1}Di")]
  marker_ids = which(colnames(fcsB) %in% marker_names)
  fcsB@exprs[,marker_ids]
})
length(sample_list)
```

Combine all samples into one `data.frame` and merge with information from sample table.

```{r combine_samples}
combine_samples = function(sample_id) {
  sample_info = sample_table[sample_id,]
  cat(as.character(sample_info$file_name),"\n")
  sample = sample_list[[sample_id]]
  rownames(sample_info) = NULL
  data.frame(sample,sample_info)
}
df_samples = lapply(1:length(sample_list),combine_samples) %>%
  do.call(rbind,.)
```

The combined `data.frame` whas the following dimensions and column names.

```{r}
dim(df_samples)
names(df_samples)
```

Change marker name from isotope name to protein name and remove markers that are unmapped.

```{r map_protein_names}
markers = read.csv("markers.csv",stringsAsFactors = FALSE)
markers$type = as.factor(markers$type)
for(i in 1:length(markers$isotope)) {
  isotope_name = markers$isotope[i]
  col_id = which(isotope_name==names(df_samples))
  names(df_samples)[col_id] = markers$protein_name[i]
}
unmapped = str_detect(names(df_samples),"[0-9]{1}Di")
df_samples = df_samples[,!unmapped]
num_markers = ncol(df_samples)-ncol(sample_table)
num_markers
protein_names = names(df_samples)[1:num_markers]
protein_names
```

Transform data with ``arcsinh`` and scale parameter set to $b = 1/5$ as in Bendall et al. 2011.

```{r transform_expressions}
b = 5
transform_expr = asinh(df_samples[1:num_markers]/b)
df_samples = data.frame(transform_expr,
                        df_samples[,(num_markers+1):ncol(df_samples)])
```

Now we are done with the data preparation steps. We have one `data.frame` we called `df_samples` that contains all the necessary information. We will now use the `CytoGLMM` package to visualize expression profiles and perform differential analysis.

```{r}
head(df_samples)
```

## Visualize Marker Expressions

The `CytoGLMM` provides some visualization functions to easily explore expression profiles. This is particullarly useful to explore the donor specific variabilty by decomposing the expression of each donor into facets.

```{r}
plot_markers(df_samples = df_samples,
            donor_id = df_samples$donor[1],
            protein_names = protein_names)
```

Plot just one marker and facet by donor.

```{r}
plot_donors(df_samples = df_samples,
            protein_name = "CD16",
            histogram = TRUE)
```

## Logistic Regression

Under the hood: For the fast maximum likelihood solution, we load the `mbest` package. For sampling from the full Bayesian posterior distribution, we load the `rstan` package.
